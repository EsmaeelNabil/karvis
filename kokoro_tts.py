import os
import subprocess
from mlx_audio.tts.models.kokoro import KokoroPipeline
from mlx_audio.tts.utils import load_model
import soundfile as sf

class KokoroTTS:
    """
    Handles text-to-speech generation and playback using the Kokoro model.
    """
    def __init__(
        self,
        kokoro_model_id: str = "prince-canuma/Kokoro-82M",
        lang_code: str = "b", # Assuming 'b' is a valid code for your Kokoro setup
        voice: str = "af_heart",
        speed: float = 1.0,
        split_pattern: str = r"\n+", # Pattern used internally by pipeline if needed
        audio_file: str = "assistant_output.wav",
    ):
        """
        Initializes the Kokoro TTS handler and loads the model.

        Args:
            kokoro_model_id (str): Identifier for the Kokoro model repository.
            lang_code (str): Language code for TTS generation.
            voice (str): The specific voice to use.
            speed (float): Speech playback speed multiplier.
            split_pattern (str): Regex pattern to split text for segment generation.
                                 (Note: often handled within the pipeline itself)
            audio_file (str): Path to save the generated audio file.
        """
        self.lang_code = lang_code
        self.voice = voice
        self.speed = speed
        self.split_pattern = split_pattern # Passed to pipeline during generation
        self.audio_file = audio_file
        self.sample_rate = 24000 # Common sample rate for Kokoro

        # Load Kokoro TTS model and pipeline once
        try:
            print(f"Loading Kokoro model: {kokoro_model_id}...")
            self.kokoro_model = load_model(kokoro_model_id)
            self.pipeline = KokoroPipeline(
                lang_code=self.lang_code,
                model=self.kokoro_model,
                repo_id=kokoro_model_id,
            )
            print("Kokoro model loaded successfully.")
        except Exception as e:
            print(f"Error loading Kokoro model ({kokoro_model_id}): {e}")
            self.pipeline = None # Mark pipeline as unavailable

    def play_text(self, text: str) -> None:
        """
        Generates TTS audio from the given text using Kokoro and plays it back.

        Args:
            text (str): The text to synthesize into speech.
        """
        if not self.pipeline:
            print("TTS pipeline not available due to loading error.")
            return
        if not text:
            print("No text provided for TTS.")
            return

        try:
            print("Generating TTS audio...")
            # Generate audio chunks (segments)
            # Note: The pipeline likely handles splitting internally based on its training/config
            # but we pass the split_pattern anyway if the specific pipeline uses it.
            segments = list(self.pipeline(
                text,
                voice=self.voice,
                speed=self.speed,
                split_pattern=self.split_pattern, # Pass pattern here
            ))

            if not segments:
                print("No audio segments generated by Kokoro.")
                return

            # For simplicity, concatenate all segments if multiple exist,
            # or just use the first one. Kokoro often returns one segment for short text.
            # Assuming segment format is [ (text_chunk, mel_spec, waveform), ... ]
            # And waveform is segments[i][2][0]
            # We need to concatenate the waveforms if there are multiple segments.
            
            # Check structure of segments - Adjust if needed based on actual output
            if segments and isinstance(segments[0], tuple) and len(segments[0]) >= 3 and \
               isinstance(segments[0][2], (list, tuple)) and len(segments[0][2]) > 0:
                
                full_audio = segments[0][2][0] # Start with the first segment's audio
                # If there are more segments, concatenate them (requires numpy)
                if len(segments) > 1:
                    try:
                        import numpy as np
                        all_waveforms = [seg[2][0] for seg in segments if seg[2]]
                        full_audio = np.concatenate(all_waveforms)
                    except ImportError:
                         print("Warning: Numpy not installed. Only using the first audio segment.")
                    except Exception as concat_e:
                         print(f"Warning: Error concatenating audio segments: {concat_e}. Using first segment.")
                
                # Save the (potentially concatenated) audio
                sf.write(self.audio_file, full_audio, self.sample_rate)
                print(f"Audio saved to {self.audio_file}")
                self._play_audio(self.audio_file)

            else:
                 print("Warning: Unexpected segment structure from Kokoro pipeline.")


        except Exception as e:
            print(f"Error during TTS generation or playback: {e}")

    def _play_audio(self, audio_file: str) -> None:
        """
        Internal method to play the generated audio file using system commands.
        Tries macOS 'afplay', then Linux 'aplay'. Warns if neither is found.
        """
        if not os.path.exists(audio_file):
            print(f"Audio file not found: {audio_file}")
            return
            
        try:
            # Check for afplay (macOS)
            if subprocess.call(["which", "afplay"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0:
                print("Playing audio using afplay...")
                subprocess.run(["afplay", audio_file], check=True)
            # Check for aplay (Linux/ALSA)
            elif subprocess.call(["which", "aplay"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0:
                print("Playing audio using aplay...")
                subprocess.run(["aplay", audio_file], check=True)
            else:
                print("Neither 'afplay' nor 'aplay' found. Please play the audio file manually:")
                print(f"Audio file saved at: {os.path.abspath(audio_file)}")
        except subprocess.CalledProcessError as e:
            print(f"Error playing audio: {e}")
        except FileNotFoundError:
             print("Error: 'which' command not found. Cannot determine audio player.")
        except Exception as e:
            print(f"An unexpected error occurred during audio playback: {e}")
